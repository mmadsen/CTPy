<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>CTPy: ctpy.math.simulation_calculations.SimulationCalculations Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CTPy
   &#160;<span id="projectnumber">1.0.3</span>
   </div>
   <div id="projectbrief">Cultural Transmission using simuPOP</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>ctpy</b></li><li class="navelem"><b>math</b></li><li class="navelem"><b>simulation_calculations</b></li><li class="navelem"><a class="el" href="classctpy_1_1math_1_1simulation__calculations_1_1_simulation_calculations.html">SimulationCalculations</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classctpy_1_1math_1_1simulation__calculations_1_1_simulation_calculations-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ctpy.math.simulation_calculations.SimulationCalculations Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Common Values #############.  
 <a href="classctpy_1_1math_1_1simulation__calculations_1_1_simulation_calculations.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab00bd033de015209aba7b2e10f547d5d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab00bd033de015209aba7b2e10f547d5d"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__init__</b></td></tr>
<tr class="separator:ab00bd033de015209aba7b2e10f547d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e2aee1058529d61399e51767a12460"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classctpy_1_1math_1_1simulation__calculations_1_1_simulation_calculations.html#a26e2aee1058529d61399e51767a12460">compute_sim_param_combinations</a></td></tr>
<tr class="memdesc:a26e2aee1058529d61399e51767a12460"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of simulation parameter combinations can probably be reduced to the Cartesian product of innovation rates and overall population sizes.  <a href="#a26e2aee1058529d61399e51767a12460">More...</a><br/></td></tr>
<tr class="separator:a26e2aee1058529d61399e51767a12460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4774a281ed7c5b5c80a0440b6d12949"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classctpy_1_1math_1_1simulation__calculations_1_1_simulation_calculations.html#af4774a281ed7c5b5c80a0440b6d12949">compute_even_dimension_classifications</a></td></tr>
<tr class="memdesc:af4774a281ed7c5b5c80a0440b6d12949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classification Combinations #############.  <a href="#af4774a281ed7c5b5c80a0440b6d12949">More...</a><br/></td></tr>
<tr class="separator:af4774a281ed7c5b5c80a0440b6d12949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9ffc30a7e7c68dca35021e193fcad0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classctpy_1_1math_1_1simulation__calculations_1_1_simulation_calculations.html#a8f9ffc30a7e7c68dca35021e193fcad0">compute_random_dimension_classifications</a></td></tr>
<tr class="memdesc:a8f9ffc30a7e7c68dca35021e193fcad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each dimensionality, we have R classifications per level of mode partitioning M.  <a href="#a8f9ffc30a7e7c68dca35021e193fcad0">More...</a><br/></td></tr>
<tr class="separator:a8f9ffc30a7e7c68dca35021e193fcad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b960cd6d285a6de588321c02c00cb77"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classctpy_1_1math_1_1simulation__calculations_1_1_simulation_calculations.html#a8b960cd6d285a6de588321c02c00cb77">compute_total_classifications</a></td></tr>
<tr class="memdesc:a8b960cd6d285a6de588321c02c00cb77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Since dimensionality is a property of subsampling the simulation output into separate data samples, any given data sample stream has a specific dimensionality (and other configuration parameters).  <a href="#a8b960cd6d285a6de588321c02c00cb77">More...</a><br/></td></tr>
<tr class="separator:a8b960cd6d285a6de588321c02c00cb77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad455df8e83ed3d3bc0fba5edbca5b79c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classctpy_1_1math_1_1simulation__calculations_1_1_simulation_calculations.html#ad455df8e83ed3d3bc0fba5edbca5b79c">compute_total_classifications_across_dimensionality</a></td></tr>
<tr class="memdesc:ad455df8e83ed3d3bc0fba5edbca5b79c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sometimes we want to know how many classifications there are, across all the levels of dimensionality.  <a href="#ad455df8e83ed3d3bc0fba5edbca5b79c">More...</a><br/></td></tr>
<tr class="separator:ad455df8e83ed3d3bc0fba5edbca5b79c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908df80f1b75622aa3ac55786c826e45"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classctpy_1_1math_1_1simulation__calculations_1_1_simulation_calculations.html#a908df80f1b75622aa3ac55786c826e45">compute_total_simulation_runs_simple</a></td></tr>
<tr class="memdesc:a908df80f1b75622aa3ac55786c826e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single Population Models (Simple Models) ############.  <a href="#a908df80f1b75622aa3ac55786c826e45">More...</a><br/></td></tr>
<tr class="separator:a908df80f1b75622aa3ac55786c826e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1cb4ca9f1b3eb820c6c55290b54442"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classctpy_1_1math_1_1simulation__calculations_1_1_simulation_calculations.html#a0d1cb4ca9f1b3eb820c6c55290b54442">compute_total_simulation_replicates_simple</a></td></tr>
<tr class="memdesc:a0d1cb4ca9f1b3eb820c6c55290b54442"><td class="mdescLeft">&#160;</td><td class="mdescRight">For single population models, the number of simulation replicates is just the number of simulation parameter combinations times the number of simuPOP replicates.  <a href="#a0d1cb4ca9f1b3eb820c6c55290b54442">More...</a><br/></td></tr>
<tr class="separator:a0d1cb4ca9f1b3eb820c6c55290b54442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa6bcc1a6b782731e34b9b45debd19ba"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classctpy_1_1math_1_1simulation__calculations_1_1_simulation_calculations.html#aaa6bcc1a6b782731e34b9b45debd19ba">compute_total_sample_size_replicates_simple</a></td></tr>
<tr class="memdesc:aaa6bcc1a6b782731e34b9b45debd19ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each simulation replicate in each run, we're also taking a variety of sample sizes of individuals for recording aggregate statistics and capturing genotypes for classification.  <a href="#aaa6bcc1a6b782731e34b9b45debd19ba">More...</a><br/></td></tr>
<tr class="separator:aaa6bcc1a6b782731e34b9b45debd19ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04fd402c83c49ebeb20edbbf33371ea"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classctpy_1_1math_1_1simulation__calculations_1_1_simulation_calculations.html#af04fd402c83c49ebeb20edbbf33371ea">compute_total_replicates_ssize_dimensionality</a></td></tr>
<tr class="memdesc:af04fd402c83c49ebeb20edbbf33371ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">From the raw sim runs, we also study different dimensionality by subsampling.  <a href="#af04fd402c83c49ebeb20edbbf33371ea">More...</a><br/></td></tr>
<tr class="separator:af04fd402c83c49ebeb20edbbf33371ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4ad989ba3ccb1dcbbe74516582399c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classctpy_1_1math_1_1simulation__calculations_1_1_simulation_calculations.html#a8b4ad989ba3ccb1dcbbe74516582399c">compute_total_replicates_ssize_dimensionality_classifications</a></td></tr>
<tr class="memdesc:a8b4ad989ba3ccb1dcbbe74516582399c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If we identify every replicate (given level of dimensionality, sample size, and combination of simulation parameters) with every even and random classification applicable to the given level of dimensionality, we end up with this many separate data stream samples.  <a href="#a8b4ad989ba3ccb1dcbbe74516582399c">More...</a><br/></td></tr>
<tr class="separator:a8b4ad989ba3ccb1dcbbe74516582399c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f674e430d656ea58e8a65fecf828e89"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classctpy_1_1math_1_1simulation__calculations_1_1_simulation_calculations.html#a5f674e430d656ea58e8a65fecf828e89">compute_total_sample_paths_ssize_dim_class_taduration</a></td></tr>
<tr class="memdesc:a5f674e430d656ea58e8a65fecf828e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">If we aggregate raw sample paths at a variety of durations, and classify the results in addition to the raw unaggregated samples paths, this is the number of total sample paths that results.  <a href="#a5f674e430d656ea58e8a65fecf828e89">More...</a><br/></td></tr>
<tr class="separator:a5f674e430d656ea58e8a65fecf828e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708d30886bbcf7f47275c068dcc48d22"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classctpy_1_1math_1_1simulation__calculations_1_1_simulation_calculations.html#a708d30886bbcf7f47275c068dcc48d22">compute_total_number_samples_simple_models</a></td></tr>
<tr class="memdesc:a708d30886bbcf7f47275c068dcc48d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of "samples" (sets of observations at a given level of ssize, dim, class, TA duration, simparams, replicated N times).  <a href="#a708d30886bbcf7f47275c068dcc48d22">More...</a><br/></td></tr>
<tr class="separator:a708d30886bbcf7f47275c068dcc48d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0296fdc56eb45ac033f54911bd544003"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classctpy_1_1math_1_1simulation__calculations_1_1_simulation_calculations.html#a0296fdc56eb45ac033f54911bd544003">compute_total_number_samples_notimeavg_simple_models</a></td></tr>
<tr class="memdesc:a0296fdc56eb45ac033f54911bd544003"><td class="mdescLeft">&#160;</td><td class="mdescRight">For analyses with just raw samples, and no time averaging, this is the number of "samples" (sets of observations at a given level of ssize, dim, class, simparams, replicated N times).  <a href="#a0296fdc56eb45ac033f54911bd544003">More...</a><br/></td></tr>
<tr class="separator:a0296fdc56eb45ac033f54911bd544003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24f85fb2f5c2d6583d424450797e620"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classctpy_1_1math_1_1simulation__calculations_1_1_simulation_calculations.html#af24f85fb2f5c2d6583d424450797e620">compute_network_param_combinations</a></td></tr>
<tr class="memdesc:af24f85fb2f5c2d6583d424450797e620"><td class="mdescLeft">&#160;</td><td class="mdescRight">metapopulation models #####################  <a href="#af24f85fb2f5c2d6583d424450797e620">More...</a><br/></td></tr>
<tr class="separator:af24f85fb2f5c2d6583d424450797e620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b8bc79f51913c9ec1de88f2077923f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classctpy_1_1math_1_1simulation__calculations_1_1_simulation_calculations.html#a80b8bc79f51913c9ec1de88f2077923f">compute_total_network_realizations</a></td></tr>
<tr class="memdesc:a80b8bc79f51913c9ec1de88f2077923f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of network realizations is the number of network parameter combinations times the number of replicates we'll study per parameter combination.  <a href="#a80b8bc79f51913c9ec1de88f2077923f">More...</a><br/></td></tr>
<tr class="separator:a80b8bc79f51913c9ec1de88f2077923f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c7d2bde540dc4a98bf68030f7858b2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classctpy_1_1math_1_1simulation__calculations_1_1_simulation_calculations.html#ab4c7d2bde540dc4a98bf68030f7858b2">compute_total_simulation_runs_metapopulation</a></td></tr>
<tr class="memdesc:ab4c7d2bde540dc4a98bf68030f7858b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applicable to metapopulation models with networks of demes.  <a href="#ab4c7d2bde540dc4a98bf68030f7858b2">More...</a><br/></td></tr>
<tr class="separator:ab4c7d2bde540dc4a98bf68030f7858b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2a4b527030b8870dc61c594058e8f4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classctpy_1_1math_1_1simulation__calculations_1_1_simulation_calculations.html#a9a2a4b527030b8870dc61c594058e8f4">compute_total_simulation_replicates_metapopulation</a></td></tr>
<tr class="memdesc:a9a2a4b527030b8870dc61c594058e8f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applicable to metapopulation models with networks of demes.  <a href="#a9a2a4b527030b8870dc61c594058e8f4">More...</a><br/></td></tr>
<tr class="separator:a9a2a4b527030b8870dc61c594058e8f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad4d81250f51646c2fc9446b2890a59"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ad4d81250f51646c2fc9446b2890a59"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classctpy_1_1math_1_1simulation__calculations_1_1_simulation_calculations.html#a8ad4d81250f51646c2fc9446b2890a59">compute_replicates_ssize_dimensionality_metapop</a></td></tr>
<tr class="memdesc:a8ad4d81250f51646c2fc9446b2890a59"><td class="mdescLeft">&#160;</td><td class="mdescRight">:return: <br/></td></tr>
<tr class="separator:a8ad4d81250f51646c2fc9446b2890a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf5ec800072697168f6e8637500d960"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1cf5ec800072697168f6e8637500d960"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classctpy_1_1math_1_1simulation__calculations_1_1_simulation_calculations.html#a1cf5ec800072697168f6e8637500d960">compute_replicates_ssize_dim_classified_metapop</a></td></tr>
<tr class="memdesc:a1cf5ec800072697168f6e8637500d960"><td class="mdescLeft">&#160;</td><td class="mdescRight">:return: <br/></td></tr>
<tr class="separator:a1cf5ec800072697168f6e8637500d960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0159756aa16d7b4c2229ca4d143b05df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0159756aa16d7b4c2229ca4d143b05df"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classctpy_1_1math_1_1simulation__calculations_1_1_simulation_calculations.html#a0159756aa16d7b4c2229ca4d143b05df">compute_replicates_ssize_dim_classified_timeaveraged</a></td></tr>
<tr class="memdesc:a0159756aa16d7b4c2229ca4d143b05df"><td class="mdescLeft">&#160;</td><td class="mdescRight">:return: <br/></td></tr>
<tr class="separator:a0159756aa16d7b4c2229ca4d143b05df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:af7970b2eae3b3acd6133b9f96373d3de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7970b2eae3b3acd6133b9f96373d3de"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>simconfig</b></td></tr>
<tr class="separator:af7970b2eae3b3acd6133b9f96373d3de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Common Values #############. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="af4774a281ed7c5b5c80a0440b6d12949"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ctpy.math.simulation_calculations.SimulationCalculations.compute_even_dimension_classifications </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Classification Combinations #############. </p>
<p>For each dimensionality, we will have one classification per level of mode partitioning (i.e., a classification which chops dimensions into 2 modes, one which chops dimensions into 4 modes, etc). TODO: We might also want classifications which are even, but different levels of partitioning for different dimensions...? :return: number of classifications with even dimensions </p>

</div>
</div>
<a class="anchor" id="af24f85fb2f5c2d6583d424450797e620"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ctpy.math.simulation_calculations.SimulationCalculations.compute_network_param_combinations </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>metapopulation models ##################### </p>
<p>The number of network model parameter combinations is important because for each combination, we will then test a number of random realizations, and each random realization will be run at all simulation parameter combinations. This value is currently the product of the levels of clustering coefficient and small-world rewiring probability that we're testing.</p>
<p>:return: number of network parameter combinations to test </p>

</div>
</div>
<a class="anchor" id="a8f9ffc30a7e7c68dca35021e193fcad0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ctpy.math.simulation_calculations.SimulationCalculations.compute_random_dimension_classifications </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For each dimensionality, we have R classifications per level of mode partitioning M. </p>
<p>For each of the R classifications, the M modes have random boundaries chosen uniformly. TODO: We might want classifications which have different levels of M per dimension, but random mode boundaries....? :return: number of classifications with M mode partitions, given R randomly generated partitions per value of M </p>

</div>
</div>
<a class="anchor" id="a26e2aee1058529d61399e51767a12460"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ctpy.math.simulation_calculations.SimulationCalculations.compute_sim_param_combinations </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of simulation parameter combinations can probably be reduced to the Cartesian product of innovation rates and overall population sizes. </p>
<p>The number of trait dimensions can &ndash; IF simuPOP evolves each locus independently in terms of mutations &ndash; be a post-processing step. All "raw" simulation runs would occur with the highest number of dimensions studied (say, 8), and then to study a smaller number of dimensions (say, 2), we'd simply extract two dimensions from the raw dataset.</p>
<p>:return: number of simuPOP parameter combinations to test </p>

</div>
</div>
<a class="anchor" id="a8b960cd6d285a6de588321c02c00cb77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ctpy.math.simulation_calculations.SimulationCalculations.compute_total_classifications </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Since dimensionality is a property of subsampling the simulation output into separate data samples, any given data sample stream has a specific dimensionality (and other configuration parameters). </p>
<p>We want, then, to identify the sample stream through each of the even and random classifications we pre-define. :return: number of total even and random classifications </p>

</div>
</div>
<a class="anchor" id="ad455df8e83ed3d3bc0fba5edbca5b79c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ctpy.math.simulation_calculations.SimulationCalculations.compute_total_classifications_across_dimensionality </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sometimes we want to know how many classifications there are, across all the levels of dimensionality. </p>
<p>:return: number of total classifications across all dimensions </p>

</div>
</div>
<a class="anchor" id="a80b8bc79f51913c9ec1de88f2077923f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ctpy.math.simulation_calculations.SimulationCalculations.compute_total_network_realizations </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of network realizations is the number of network parameter combinations times the number of replicates we'll study per parameter combination. </p>
<p>:return: number of network realizations to test </p>

</div>
</div>
<a class="anchor" id="a0296fdc56eb45ac033f54911bd544003"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ctpy.math.simulation_calculations.SimulationCalculations.compute_total_number_samples_notimeavg_simple_models </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For analyses with just raw samples, and no time averaging, this is the number of "samples" (sets of observations at a given level of ssize, dim, class, simparams, replicated N times). </p>
<p>:return: number of sets of distinct observations including replication at each "combination" of treatments, without any time averaging </p>

</div>
</div>
<a class="anchor" id="a708d30886bbcf7f47275c068dcc48d22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ctpy.math.simulation_calculations.SimulationCalculations.compute_total_number_samples_simple_models </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The total number of "samples" (sets of observations at a given level of ssize, dim, class, TA duration, simparams, replicated N times). </p>
<p>:return: number of sets of distinct observations including replication at each "combination" of treatments </p>

</div>
</div>
<a class="anchor" id="af04fd402c83c49ebeb20edbbf33371ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ctpy.math.simulation_calculations.SimulationCalculations.compute_total_replicates_ssize_dimensionality </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>From the raw sim runs, we also study different dimensionality by subsampling. </p>
<p>This leads to genotype and statistics which are distinct for each level of dimensionality, at each sample size, FOR each combination of simulation parameters, by the number of replicates at each sim param combination...</p>
<p>:return: number of replicates at each dimensionality and sample size and param combo, given replication level </p>

</div>
</div>
<a class="anchor" id="a8b4ad989ba3ccb1dcbbe74516582399c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ctpy.math.simulation_calculations.SimulationCalculations.compute_total_replicates_ssize_dimensionality_classifications </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If we identify every replicate (given level of dimensionality, sample size, and combination of simulation parameters) with every even and random classification applicable to the given level of dimensionality, we end up with this many separate data stream samples. </p>
<p>:return: number of data sample streams given classification, dimensionality, ssize, sim params </p>

</div>
</div>
<a class="anchor" id="a5f674e430d656ea58e8a65fecf828e89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ctpy.math.simulation_calculations.SimulationCalculations.compute_total_sample_paths_ssize_dim_class_taduration </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If we aggregate raw sample paths at a variety of durations, and classify the results in addition to the raw unaggregated samples paths, this is the number of total sample paths that results. </p>
<p>:return: number of data sample streams given class, dim, ssize, simparam, taduration </p>

</div>
</div>
<a class="anchor" id="aaa6bcc1a6b782731e34b9b45debd19ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ctpy.math.simulation_calculations.SimulationCalculations.compute_total_sample_size_replicates_simple </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For each simulation replicate in each run, we're also taking a variety of sample sizes of individuals for recording aggregate statistics and capturing genotypes for classification. </p>
<p>This increases the total number of sample "streams" by a factor. :return: number of simulation replicates for each sample size factor </p>

</div>
</div>
<a class="anchor" id="a9a2a4b527030b8870dc61c594058e8f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ctpy.math.simulation_calculations.SimulationCalculations.compute_total_simulation_replicates_metapopulation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applicable to metapopulation models with networks of demes. </p>
<p>The number of simulation replicates is the number of simulation execution runs, times the number of replications we ask simuPOP to do for every parameter combination and network realization (i.e., configuration).</p>
<p>:return: number of total simulation replicates across all parameter and network combinations </p>

</div>
</div>
<a class="anchor" id="a0d1cb4ca9f1b3eb820c6c55290b54442"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ctpy.math.simulation_calculations.SimulationCalculations.compute_total_simulation_replicates_simple </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For single population models, the number of simulation replicates is just the number of simulation parameter combinations times the number of simuPOP replicates. </p>
<p>:return: number of simulation replicates for a single population model </p>

</div>
</div>
<a class="anchor" id="ab4c7d2bde540dc4a98bf68030f7858b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ctpy.math.simulation_calculations.SimulationCalculations.compute_total_simulation_runs_metapopulation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applicable to metapopulation models with networks of demes. </p>
<p>The number of simulation runs (i.e., execution runs) is the product of the number of simulation parameter combinations and the number of network realizations against which we want to test. Note that each execution run can generate multiple independent replicates of those parameters in simuPOP, so this is NOT the number of independent data sample streams.</p>
<p>:return: number of total simulation execution runs </p>

</div>
</div>
<a class="anchor" id="a908df80f1b75622aa3ac55786c826e45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ctpy.math.simulation_calculations.SimulationCalculations.compute_total_simulation_runs_simple </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single Population Models (Simple Models) ############. </p>
<p>For single population models, the number of simulation runs is just the number of simulation parameter combinations, so this is a pass through. :return: number of simulation runs for a single population model </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ctpy/math/simulation_calculations.py</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Oct 13 2013 16:46:26 for CTPy by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
